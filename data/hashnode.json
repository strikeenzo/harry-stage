{"posts":[{"_id":"627f7ab5bc9305ec39362c1a","slug":"make-a-beautiful-connect-wallet-button-with-rainbowkit-and-react","title":"Make a beautiful Connect Wallet Button with RainbowKit and React","brief":"Authentication in Web3 is extremely easy but supporting all the wallets and making a nice UI can be painful and time-consuming. Thankfully, there are many libraries which makes this extremely easy as well. Today we are going to be looking at adding R...","coverImage":"https://cdn.hashnode.com/res/hashnode/image/upload/v1652521066137/sJ3tsAZoN.png","dateAdded":"2022-05-14T09:47:33.362Z","contentMarkdown":"Authentication in Web3 is extremely easy but supporting all the wallets and making a nice UI can be painful and time-consuming. Thankfully, there are many libraries which makes this extremely easy as well. Today we are going to be looking at adding [RainbowKit](https://www.rainbowkit.com/) to a React App.\n\n## What is RainbowKit?\nRainbowKit is a React library that provides us with components to build a Connect Wallet UI in a few lines of code. It comes with support for many wallets, including Metamask, Rainbow, Coinbase Wallet, WalletConnect, and many more. It is also extremely customizable and comes with an amazing built-in theme.\n\nRainbowKit uses [Ethers.js](https://github.com/ethers-io/ethers.js) and [Wagmi](https://github.com/tmm/wagmi), both popular libraries in this space, under the hood.\n\nAlso, it is developed by the same team behind the beautiful [Rainbow Wallet](https://rainbow.me/)\n\n## Creating a new Next.js App\nRun the following command to create a new Next.js app (note that you can use it on a regular React app too) - \n```sh\n# With NPM\nnpx create-next-app rainbowkit-demo\n# With yarn\nyarn create next-app rainbowkit-demo\n```\n\nNow, move into the project directory and open it in your favorite code editor.\n\n## Adding RainbowKit to our React app\nRun the following command to install RainbowKit and its peer dependencies - \n```sh\n# With NPM\nnpm install @rainbow-me/rainbowkit wagmi ethers\n# With yarn\nyarn add @rainbow-me/rainbowkit wagmi ethers\n```\n\nNow add the following code to `pages/_app.js` -\n```js\nimport \"../styles/globals.css\";\n\nimport \"@rainbow-me/rainbowkit/styles.css\";\n\nimport {\n  apiProvider,\n  configureChains,\n  getDefaultWallets,\n  RainbowKitProvider,\n} from \"@rainbow-me/rainbowkit\";\nimport { chain, createClient, WagmiProvider } from \"wagmi\";\n\nconst { chains, provider } = configureChains(\n  [\n    chain.mainnet,\n    chain.polygon,\n    chain.goerli,\n    chain.rinkeby,\n    chain.polygonMumbai,\n  ],\n  [apiProvider.fallback()]\n);\n\nconst { connectors } = getDefaultWallets({\n  appName: \"My RainbowKit App\",\n  chains,\n});\n\nconst wagmiClient = createClient({\n  autoConnect: true,\n  connectors,\n  provider,\n});\n\nfunction MyApp({ Component, pageProps }) {\n  return (\n    <WagmiProvider client={wagmiClient}>\n      <RainbowKitProvider chains={chains}>\n        <Component {...pageProps} />\n      </RainbowKitProvider>\n    </WagmiProvider>\n  );\n}\n\nexport default MyApp;\n```\n\nFirstly, we import the RainbowKit styles, the `RainbowKitPovider` and other functions to configure our chains, and the `WagmiProvider`.\n\nNext, we configure the chains which we want to support. In this example, I have added the Ethereum Mainnet, Polygon Mainnet, Goerli and Rinkeby (both Ethereum test networks), and the Polygon Mumbai testnet. We are using the public fallback RPC URLs for the purpose of this demo for our API providers. RainbowKit also lets us specify our own JSON RPC URLs or Alchemy or Infura URLs for our API providers. You can see the [API Providers documentation here](https://www.rainbowkit.com/docs/api-providers).\n\nNext, we create our `wagmiClient`, passing in the `autoConnect` and setting it to `true`. Our app will automatically reconnect to the last used connector this way.\n\nAt last, we wrap our application with `WagmiProvider` and `RainbowKitProvider`. \n\nNext, let us add the Connect Wallet button to our app. Replace the code in `pages/index.js` with the following - \n\n```js\nimport { ConnectButton } from \"@rainbow-me/rainbowkit\";\nimport Head from \"next/head\";\nimport styles from \"../styles/Home.module.css\";\n\nexport default function Home() {\n  return (\n    <div className={styles.container}>\n      <Head>\n        <title>RainbowKit Demo</title>\n        <meta\n          name=\"description\"\n          content=\"Demo app part of a tutorial on adding RainbowKit to a React application\"\n        />\n        <link rel=\"icon\" href=\"/favicon.ico\" />\n      </Head>\n\n      <main className={styles.main}>\n        <h1 className={styles.title} style={{ marginBottom: \"4rem\" }}>\n          Welcome to this demo of{\" \"}\n          <a href=\"https://www.rainbowkit.com/\">RainbowKit</a>\n        </h1>\n\n        <ConnectButton />\n      </main>\n    </div>\n  );\n}\n```\nNow run `npm run dev` or `yarn dev` and open up [localhost:3000](http://localhost:3000) in your browser and you should see this - \n\n![Peek 2022-05-14 14-22.gif](https://cdn.hashnode.com/res/hashnode/image/upload/v1652518368819/WWI1V_IJQ.gif)\n\n## Making it dark mode 🌑\nTime to make sure our eyes don't burn anymore. \n\nHead over to `pages/_app.js` and import the `midnightTheme` function from RainbowKit. (Alternatively, you can also import the `darkTheme` function, a dimmer version of midnight)\n```js\nimport {\n  apiProvider,\n  configureChains,\n  getDefaultWallets,\n  midnightTheme,\n  RainbowKitProvider,\n} from \"@rainbow-me/rainbowkit\";\n```\n\nWe must also pass in our theme to `RainbowKitProvider` - \n```js\n<RainbowKitProvider chains={chains} theme={midnightTheme()}>\n```\n\nRainbowKit supports more advanced theming, you can see the [RainbowKit Theming docs here](https://www.rainbowkit.com/docs/theming) for more information.\n\nAlso, add this small piece of code to `styles/globals.css` to make our app dark mode too - \n```css\nbody {\n  background-color: #010101;\n  color: #f0f0f0;\n}\n```\n\nNow our app should look like this - \n\n![Peek 2022-05-14 14-31.gif](https://cdn.hashnode.com/res/hashnode/image/upload/v1652518912187/Z5fwbguf9.gif)\n\n## A tour of RainbowKit\n\nAfter authenticating with a wallet, our connect button will automatically change to a network switcher which also show us our balance and wallet address - \n\n![image.png](https://cdn.hashnode.com/res/hashnode/image/upload/v1652518983014/PG0nny96e.png)\n\nSwitching the network is as easy as clicking the network switcher and then selecting the network we want to switch to - \n\n![Peek 2022-05-14 14-33.gif](https://cdn.hashnode.com/res/hashnode/image/upload/v1652519079358/IRQKD8BrJ.gif)\n\nClicking on our wallet address gives us a modal with the option to copy our address or disconnect our wallet - \n\n![Peek 2022-05-14 14-35.gif](https://cdn.hashnode.com/res/hashnode/image/upload/v1652519167948/wZBoGNlNT.gif)\n\n## Cool Mode 😎\nLet's make our application a little cooler :)\nJust add the `coolMode` prop to `RainbowKitProvider` -\n```js\n<RainbowKitProvider chains={chains} theme={midnightTheme()} coolMode>\n```\n\nNow if we click on any of the options in the connect modal, we will get some amazing confetti 🎊\n\n![Peek 2022-05-14 14-44.gif](https://cdn.hashnode.com/res/hashnode/image/upload/v1652519690123/kf66Lk7qK.gif)\n\n## Conclusion\nThat was a basic demo of what RainbowKit can do, but it can do a lot more like show recent transactions. The best place to learn more about it is [RainbowKit docs](https://www.rainbowkit.com/).\n\n## Important Links\n- [Source Code](https://github.com/AnishDe12020/rainbowkit-demo)\n- [Deployed Preview](https://rainbowkit-demo.vercel.app/)\n- [RainbowKit](https://www.rainbowkit.com/)\n- [RainbowKit GitHub](https://github.com/rainbow-me/rainbowkit)\n\n","readingTime":{"text":"5 min read","minutes":4.285,"time":257100,"words":857},"wordCount":858},{"_id":"6278e72f766c7b81844fa2bb","slug":"5-amazing-react-component-libraries-to-consider-for-your-next-project","title":"5 Amazing React Component Libraries to Consider for your Next Project","brief":"As web developers, it is often quite hard and time-consuming to make accessible UIs. This gets even worse when we have to make special components like Modals or Popovers from scratch.\nThankfully, the React ecosystem is huge and there are many great p...","coverImage":"https://cdn.hashnode.com/res/hashnode/image/unsplash/XmZ4GDAp9G0/upload/v1652090173489/BrJWe16IU.jpeg","dateAdded":"2022-05-09T10:04:31.347Z","contentMarkdown":"As web developers, it is often quite hard and time-consuming to make accessible UIs. This gets even worse when we have to make special components like Modals or Popovers from scratch.\n\nThankfully, the React ecosystem is huge and there are many great people who have made amazing libraries to help us with this problem. Today, we are going to focus on React component libraries that are accessible, have a decent base style, have good docs, and come with components like Modals, Popovers, Tooltips, etc.\n\n## 1. [Chakra UI](https://chakra-ui.com/)\n\n![image.png](https://cdn.hashnode.com/res/hashnode/image/upload/v1652085007803/QbhtHwWIY.png)\n\nWhen I started out with Next.js, Chakra UI was the first component library I ever used, and it was amazing! I was able to make quite complex UIs (with modals and tables and everything) in not much time and that helped me focus on other things like application logic. It is the perfect one to use for Hackathons! It also has a huge community and is extremely popular.\n\n## 2. [Next UI](https://nextui.org/)\n\n![image.png](https://cdn.hashnode.com/res/hashnode/image/upload/v1652085218540/wVFj0gDd1.png)\n\nNext UI is probably the most beautiful out of all 5 in this article. Although it is quite new and still in the beta stage, it comes with all the essentials and looks absolutely amazing out of the box! It also comes with some amazing transitions and animations out of the box, that other component libraries don't come with.\n\n## 3. [MUI](https://mui.com/)\n\n![image.png](https://cdn.hashnode.com/res/hashnode/image/upload/v1652085809008/yXZ8rAykw.png)\n\nMUI also has been around for a long time and was called Material UI. It is based on [Material Design by Google](https://material.io/) but also comes with an extensive level of customization. Moreover, MUI also provides an [unstyled version](https://mui.com/base/getting-started/installation/) and [a package with some amazing CSS utilities](https://mui.com/system/basics/). MUI also provides a set of [advanced components](https://mui.com/x/advanced-components/) under MUI X. Some of these components are free but some require a paid license.\n\n## 4. [Mantine](https://mantine.dev/)\n\n![image.png](https://cdn.hashnode.com/res/hashnode/image/upload/v1652087017990/V0lwKr61B.png)\n\nMantine also comes with a lot of components and a decent out-of-the-box UI. It is a lot like Chakra UI but has a smaller community. It, however, also comes with some amazing packages like [a notification center](https://mantine.dev/others/notifications/), [a command bar](https://mantine.dev/others/spotlight/), [a rich text editor](https://mantine.dev/others/rte/) and much more!\n\n## 5. [React Daisy UI](https://react.daisyui.com/)\n\n![image.png](https://cdn.hashnode.com/res/hashnode/image/upload/v1652088634825/dYUJWf7_n.png)\n\n[Daisy UI](https://daisyui.com/) is an amazing [Tailwind CSS ](https://tailwindcss.com/) component library. React Daisy UI is React component library for Daisy UI. It comes with a huge number of themes out of the box and a lot of components as well. As it is based on Tailwind CSS and comes with it, it is extremely easy to customize it with Tailwind CSS.\n\n## Conclusion\nNow those were 5 React component libraries that will help you speed up development. Do let me know if you have any other favorites or which one you liked the most of these 5!\n","readingTime":{"text":"3 min read","minutes":2.235,"time":134100,"words":447},"wordCount":448},{"_id":"626facff77f8e2f7fe934866","slug":"amazing-preview-images-with-nextjs-and-lqip-modern","title":"Amazing preview images with Next.js and LQIP Modern","brief":"Images take a long time to load and can have a disruptive impact on UX. Today we are going to be looking at creating preview images with a library called lqip-modern. \nWhat is LQIP?\nLQIP simply stands for Low Quality Image Placeholders. They have ext...","coverImage":"https://cdn.hashnode.com/res/hashnode/image/upload/v1651485793452/F3aixNLhI.png","dateAdded":"2022-05-02T10:05:51.829Z","contentMarkdown":"Images take a long time to load and can have a disruptive impact on UX. Today we are going to be looking at creating preview images with a library called [`lqip-modern`](https://www.npmjs.com/package/lqip-modern). \n\n## What is LQIP?\n**LQIP** simply stands for **L**ow **Q**uality **I**mage **P**laceholders. They have extremely small file sizes and act as placeholders for the actual image while the actual image is still loading. These extremely small file sizes are obtained by blurring the image, resizing it to a smaller size, or reducing the quality in the case of JPEGs.\n\n## Compatibility\nWebP is supported by all modern browsers. Also, WebP support is present in Safari on macOS only if one is using macOS 11 (Big Sur) or later. [source](https://caniuse.com/?search=webp)\n\nIf 100% compatibility is the goal, we can use JPEG LQIPs as well (they are almost 2-3 times the size of a WebP image).\n\nLet us now look at how we can use `lqip-modern` with Next.js\n\n## Using LQIP Modern with Next.js\nNext.js has an in-built [next/image](https://nextjs.org/docs/api-reference/next/image) component which can provide preview images for local files without the use of an external library, but it cannot for remote images.\n\nNow, there is also a limitation with our approach here, that is, preview images are created at build time. This means, that if the external image changes, then the preview image will not change. \n\nHowever, this method will be especially useful if you are fetching the image from a CMS. If the image is ever updated, a build can be triggered which will create a new preview image. A better approach would be to use [on-demand Incremental Static Regeneration](https://nextjs.org/docs/basic-features/data-fetching/incremental-static-regeneration#on-demand-revalidation-beta) or regular incremental static regeneration, however, that is out of the scope of this article. You can read [my blog post on implementing on-demand incremental static regeneration with Directus](https://blog.anishde.dev/making-a-blog-with-directus-mdx-and-nextjs-on-demand-isr) to learn more.\n\nIn this example, we are going to look at creating preview images for an image from Unsplash. I am going to be using [this awesome image of a Vercel mug along with some computer peripherals](https://images.unsplash.com/photo-1642083139428-9ee5fa423c46) for this tutorial. However, you can choose any picture you like.\n\nFirstly, let us create a new Next.js application - \n```\nnpx create-next-app next-lqip-demo\n# OR\nyarn create next-app next-lqip-demo\n```\n\nAfter it has been created, open up the project in your favorite code editor.\n\nNow, open up the `pages/index.js` file and replace it with the following code - \n```js\nimport Head from \"next/head\";\nimport Image from \"next/image\";\nimport styles from \"../styles/Home.module.css\";\n\nexport default function Home() {\n  return (\n    <div className={styles.container}>\n      <Head>\n        <title>LQIP demo with Next.js</title>\n        <meta name=\"description\" content=\"Generated by create next app\" />\n        <link rel=\"icon\" href=\"/favicon.ico\" />\n      </Head>\n\n      <main className={styles.main}>\n        <h1 className={styles.title}>\n          Welcome to{\" \"}\n          <a href=\"https://nextjs.org\">this demo of LQIP with Next.js!</a>\n        </h1>\n\n        <div style={{ marginTop: \"4rem\" }}>\n          <Image\n            src=\"https://images.unsplash.com/photo-1642083139428-9ee5fa423c46\"\n            alt=\"Vercel mug with computer peripherals\"\n            height={480}\n            width={320}\n          />\n        </div>\n      </main>\n    </div>\n  );\n}\n```\n\nAlso, replace the code inside `next.config.js` with the following - \n```js\n/** @type {import('next').NextConfig} */\nconst nextConfig = {\n  reactStrictMode: true,\n  images: {\n    domains: [\"images.unsplash.com\"],\n  },\n};\n\nmodule.exports = nextConfig;\n```\n\nWe are using the `next/image` component to show our image from Unsplash. As the image is from a remote URL, we have to also add the domain in `next.config.js`.\n\nNow run `npm run dev` or `yarn dev` to start a development server and then visit [localhost:3000](http://localhost:3000/). You will be able to see the page heading with the image - \n\n![image.png](https://cdn.hashnode.com/res/hashnode/image/upload/v1651481994200/3UFVupiF_.png)\n\nWhen you first visited the page, you would have noticed the image took a split of a second to load. Depending on your internet connection, it can be fast or slow. If you have a fast internet connection, open up developer tools and go to the network tab. Here you can throttle your internet connection to simulate a slow loading time - \n\n![image.png](https://cdn.hashnode.com/res/hashnode/image/upload/v1651482154248/ZMGC1ekZo.png)\n\n### Using LQIP to optimize our remote image\nFirstly, let us install `lqip-modern`, and [`sharp`](https://www.npmjs.com/package/sharp). Sharp is an awesome package that helps with image transformations and is used by `lqip-modern` - \n```\nnpm install --save lqip-modern sharp\n# OR\nyarn add lqip-modern sharp\n```\n\nNow, replace the code in `pages/index.js` with the following - \n```js\nimport lqipModern from \"lqip-modern\";\nimport Head from \"next/head\";\nimport Image from \"next/image\";\nimport styles from \"../styles/Home.module.css\";\n\nexport default function Home({ imageUrl, previewImageUrl }) {\n  return (\n    <div className={styles.container}>\n      <Head>\n        <title>LQIP demo with Next.js</title>\n        <meta name=\"description\" content=\"Generated by create next app\" />\n        <link rel=\"icon\" href=\"/favicon.ico\" />\n      </Head>\n\n      <main className={styles.main}>\n        <h1 className={styles.title}>\n          Welcome to{\" \"}\n          <a href=\"https://nextjs.org\">this demo of LQIP with Next.js!</a>\n        </h1>\n\n        <div style={{ marginTop: \"4rem\" }}>\n          <Image\n            src={imageUrl}\n            alt=\"Vercel mug with computer peripherals\"\n            height={480}\n            width={320}\n            placeholder=\"blur\"\n            blurDataURL={previewImageUrl}\n          />\n        </div>\n      </main>\n    </div>\n  );\n}\n\nexport const getStaticProps = async () => {\n  const unsplashImageUrl =\n    \"https://images.unsplash.com/photo-1642083139428-9ee5fa423c46\";\n  const image = await fetch(unsplashImageUrl);\n  const imageBuffer = Buffer.from(await image.arrayBuffer());\n  const previewImage = await lqipModern(imageBuffer);\n\n  return {\n    props: {\n      imageUrl: unsplashImageUrl,\n      previewImageUrl: previewImage.metadata.dataURIBase64,\n    },\n  };\n};\n```\n\nIn `getStaticProps`, we first fetch the image and convert it to a [Buffer](https://nodejs.org/api/buffer.html#buffer). We then give `lqip-modern` our buffer and it returns us an object called `previewImage` which contains a buffer and some metadata.  Inside the metadata, there is a field called `dataURIBase64` which is a base64 URL for our preview image. We pass this in via props to our client-side application.\n\nOn the client-side, we have added a new `placeholder=\"blur\"` parameter to our `Image` component that will show a blur placeholder. As it is a remote image, we are required to pass in the `blurDataURL` parameter. We pass in the base64 URL for our preview image we obtained from the metadata earlier, here.\n\nNow if you reload the page, while the image is loading, you should see the preview image.\n\n![Preview Image Demo.gif](https://cdn.hashnode.com/res/hashnode/image/upload/v1651483127819/2h9bDoMQI.gif)\n\nFor those wondering, this is the image `lqip-modern` made us - \n\n![image.png](https://cdn.hashnode.com/res/hashnode/image/upload/v1651483336423/yy1ZQSwDk.png)\n\nIt is tiny at just 11x16 (the `next/image` component makes it fill the width and height of the original image) and is just 78 bytes!\n\n### Using JPEG instead of WebP\nIf you want to support all browsers, you can add the `outputFormat` option when making the preview image to get a JPEG preview image, like this - \n```js\n  const previewImage = await lqipModern(imageBuffer, { outputFormat: \"jpeg\" });\n```\n\nThe JPEG image is the same dimensions as our WebP image but significantly larger in size at 303 bytes - \n\n![image.png](https://cdn.hashnode.com/res/hashnode/image/upload/v1651483539416/b63sHVUS7.png)\n\nNote that these file sizes will vary depending on what image you use. The difference in file size between JPEG and WebP can go under double in some cases.\n\n## Conclusion\nAlright, that is it! Let us go over what we did in this tutorial - \n- Learned about LQIP images\n- Created a Next.js application and added an image from Unsplash\n- Used `lqip-modern` to create preview images\n- Looked at how we can obtain JPEG preview images\n\nHope you liked this tutorial! Do share it if you have found it useful :)\n\n\n## Important Links\n- [LQIP Modern](https://www.npmjs.com/package/lqip-modern)\n- [GitHub Repository with code](https://github.com/AnishDe12020/next-lqip-demo)\n- [Deployed example](https://next-lqip-demo.vercel.app/)","readingTime":{"text":"6 min read","minutes":5.725,"time":343500,"words":1145},"wordCount":1145},{"_id":"626c0aed0c2dd1d27d008342","slug":"making-a-blog-with-directus-mdx-and-nextjs-on-demand-isr","title":"Making a blog with Directus, MDX, and Next.js On-Demand ISR","brief":"There are many Headless CMSs out there and many other tools that let us make a blog easily and quickly. Today we look at building a blog with Directus and Next.js. We will use MDX to store our blog content in Directus. We are also going to use Next.j...","coverImage":"https://cdn.hashnode.com/res/hashnode/image/upload/v1651247682343/a8z6OZ-5D.png","dateAdded":"2022-04-29T15:57:33.361Z","contentMarkdown":"There are many Headless CMSs out there and many other tools that let us make a blog easily and quickly. Today we look at building a blog with [Directus](https://directus.io/) and Next.js. We will use [MDX](https://mdxjs.com/) to store our blog content in Directus. We are also going to use [Next.js's on-demand incremental static regeneration feature](https://nextjs.org/docs/basic-features/data-fetching/incremental-static-regeneration#on-demand-revalidation-beta) which lets us add or update content on our website without triggering a re-build.\n\nDemo - \n\n%[https://www.loom.com/share/744f94ee7e74433a98134b3c0db8cac0]\n\nNote that incremental static regeneration will be referred to as ISR from now on\n\n## Why On-Demand ISR over regular ISR?\nNext.js supports ISR for a few years now but on-demand ISR makes it better. Before, we would specify a `revalidate` property with the number of seconds to cache the data. This had a few disadvantages - \n- The cache would be invalidated regularly even if the data in the server had not changed. This would also result in unnecessary API calls.\n- Often, the content served would be stale.\n\nOn-demand ISR solves both the aforementioned problems with regular ISR. This is done by triggering a cache revalidation via webhooks. So whenever the content is updated on the server (or CMS), a webhook event can be fired which will create or update the required static pages\n\n## Setting up a Directus project\nAlthough Directus can be self-hosted, it has a cloud offering with a decent free tier. Go ahead and sign up for an account if you haven't already. Click \"Create Project\" in the dashboard (you might be prompted to create one during the onboarding process) and give your project a name. Under \"Infrastructure\", select \"Community Cloud\" and under \"Starting Template\", select \"Empty Project\". Now click \"Create Project\" and within 2 minutes, it should be created.\n\n![image.png](https://cdn.hashnode.com/res/hashnode/image/upload/v1651223269097/aJVKyy2gR.png align=\"left\")\n\nAfter the project has been created, click on it on the dashboard and then click \"Open Project\". Here, on the login screen, enter the credentials that have been sent to the email address associated with your Directus account.\n\n### Setting up our Blog collection\n\nOn, Directus, it should say that there are no collections. Let us create a collection called \"Blog\". Click on the arrow in the top-right corner and check \"Status\", \"Created on\" and \"Updated On\". We will add more fields later on. Now click on the checkmark and we should be able to see our collection's schema - \n\n![image.png](https://cdn.hashnode.com/res/hashnode/image/upload/v1651223280422/6jk5xyTOb.png align=\"left\")\n\nLet us add a few more fields. Create one called with the type \"Input\" and give it the key \"title\". Make it required and hit save.\n\n![image.png](https://cdn.hashnode.com/res/hashnode/image/upload/v1651223394462/vpz-8l4b1.png align=\"left\")\n\nAdd one more field with the type \"Markdown\" and give it the key \"content\". Make this required too and hit save.\n\n![image.png](https://cdn.hashnode.com/res/hashnode/image/upload/v1651223472104/1BR8ZE5F8.png align=\"left\")\n\nWe need to also add a slug for our blog posts. Create a new field with the \"Input\" type with key \"slug\" and make it required. Now click \"Continue in Advanced Field Creation Mode\". Under \"Interface\" check the \"Slugify\" option and click the checkmark to create the field.\n\n![image.png](https://cdn.hashnode.com/res/hashnode/image/upload/v1651225354586/VbUHIbeFu.png align=\"left\")\n\n### Adding some sample data\nAdding content in Directus is extremely easy! Go to the content tab in the sidebar (the first one with a 3d box icon) and select the Blog collection. Now click \"Create Item\". Here add a title and some content and a slug. Also, make sure to change the status to \"Published\". We will later use this status to manage API access. Note that you can use markdown here. After you are done adding the content, click the checkmark to save it.\n\n### Setting up permissions for our API\nGo to the settings tab on the sidebar and then click on \"Roles & Permissions\" in the settings navigation. Next, click on \"Public\" - \n\n![image.png](https://cdn.hashnode.com/res/hashnode/image/upload/v1651224303551/x1F4OS5JD.png align=\"left\")\n\nHere we can see our Blog collection. Click on the red not allowed sign under the eye (this denotes view permission). In the dropdown, select \"Use Custom\".\n\nUnser \"Item Permissions\", add the following rule allowing public view access to only published items - \n\n![image.png](https://cdn.hashnode.com/res/hashnode/image/upload/v1651224523453/mYoGUFWzC.png align=\"left\")\n\nUnder \"Field Permissions\", select all and click on the checkmark to save the permissions.\n\n![image.png](https://cdn.hashnode.com/res/hashnode/image/upload/v1651225541073/dFphhgKhV.png align=\"left\")\n\n## Creating a blog with Next.js and Directus\nLet us start by creating a new Next.js app - \n```\nnpx create-next-app nextjs-directus-on-demand-isr\n# OR\nyarn create next-app nextjs-directus-on-demand-isr\n```\n\nAfter it has been created, open the project in your favorite code editor.\n\nNext, install the Directus JS SDK - \n\n```\nnpm install @directus/sdk\n# OR\nyarn add @directus/sdk\n```\n\nNow, make a file called `lib/directus.js` and add the following code - \n```js\nimport { Directus } from \"@directus/sdk\";\n\nconst directus = new Directus(process.env.DIRECTUS_URL);\n\nexport default directus;\n```\n\nHere, we are initializing the SDK with the URL to our Directus backend. We must set this URL as an environment variable. Go ahead and create a new file called `.env.local` and add the environment variable - \n```env\nDIRECTUS_URL=<PATH_TO_YOUR_DIRECTUS_INSTANCE_WITHOUT_ANY_OF_THE_PATHS>\n```\nMake sure to appropriately replace the URL with the one for your instance.\n\nNow, open the `pages/index.js` file and replace it with the following code - \n```js\nimport Head from \"next/head\";\nimport Link from \"next/link\";\nimport directus from \"../lib/directus\";\n\nimport styles from \"../styles/Home.module.css\";\n\nexport default function Home({ posts }) {\n  return (\n    <div className={styles.container}>\n      <Head>\n        <title>Create Next App</title>\n        <meta name=\"description\" content=\"Generated by create next app\" />\n        <link rel=\"icon\" href=\"/favicon.ico\" />\n      </Head>\n\n      <main className={styles.main}>\n        <h1 className={styles.title}>\n          Welcome to A demo of Next.js with Directus\n        </h1>\n\n        <div className={styles.grid}>\n          {posts.map((post) => (\n            <Link key={post.id} href={post.slug} passHref>\n              <a className={styles.card}>\n                <h2>{post.title}</h2>\n              </a>\n            </Link>\n          ))}\n        </div>\n      </main>\n    </div>\n  );\n}\n\nexport const getStaticProps = async () => {\n  const res = await directus.items(\"blog\").readByQuery({\n    limit: -1,\n    fields: [\"title\", \"slug\", \"id\"],\n  });\n\n  return {\n    props: {\n      posts: res.data,\n    },\n  };\n};\n```\nHere, we are fetching all the blog posts but only the title, slug, and id fields. We do this in `getStaticProps` and pass the data as a prop to the client. Hence, the fetching is done on the server environment, only at build time. (note that in a development environment, `getStaticProps` runs on every request)\n\nLater on in the article, we are going to be looking at on-demand ISR that will run `getStaticProps` when a webhook is triggered.\n\nOnce you run `yarn dev` and open up [https://localhost:3000](localhost:3000) on your web browser, you should be able to see your blog posts - \n\n![image.png](https://cdn.hashnode.com/res/hashnode/image/upload/v1651230716520/vtByp3p3R.png align=\"left\")\n\nNow, if we click on the blog post cards, it will lead us to a 404 as we haven't set up our blog post pages yet. Let us do that now.\n\nCreate a new file `pages/[slug].js` and add the following code - \n```js\nimport directus from \"../lib/directus\";\nimport styles from \"../styles/BlogPost.module.css\";\n\nconst BlogPage = ({ post }) => {\n  return (\n    <div className={styles.container}>\n      <h1>{post.title}</h1>\n      <p>{post.content}</p>\n    </div>\n  );\n};\n\nexport const getStaticProps = async ({ params }) => {\n  const res = await directus.items(\"blog\").readByQuery({\n    filter: { slug: params.slug },\n    fields: [\"title\", \"content\"],\n  });\n\n  return {\n    props: {\n      post: res.data[0],\n    },\n  };\n};\n\nexport const getStaticPaths = async () => {\n  const res = await directus.items(\"blog\").readByQuery({\n    limit: -1,\n    fields: [\"slug\"],\n  });\n\n  return {\n    paths: res.data.map((post) => ({\n      params: {\n        slug: post.slug,\n      },\n    })),\n    fallback: false,\n  };\n};\n\nexport default BlogPage;\n```\n\nHere, in `getStaticPaths`, we are fetching only the slug for all blog posts. Then we are mapping over it and create an array of params to let Next.js know the paths that exist. Lastly, we set `fallback` to `false` so that any path not in the paths array redirects to a 404.\n\nIn `getStaticProps` we do a query where we filter by the `slug` field. We also specifically ask for only the `title` and `content` fields.\n\nLastly, we pass the data in through props and render it on the client-side.\n\nAlso, we can add some CSS for this page. Create a new file called `styles/BlogPost.module.css` and add the following to it - \n```css\n.container {\n  padding: 0 2rem;\n}\n\n.main {\n  min-height: 100vh;\n  padding: 4rem 0;\n  flex: 1;\n  display: flex;\n  flex-direction: column;\n  justify-content: center;\n  align-items: center;\n}\n```\n\nNow if we see our blog post page, we see that the content is rendering as a string and is not getting parsed as markdown - \n\n![image.png](https://cdn.hashnode.com/res/hashnode/image/upload/v1651232707540/m80wn9q-X.png align=\"left\")\n\nLet's fix this\n\n### Rendering MDX for content\nAlthough MDX supports more advanced features like the ability to render React components, we are not going to be looking at that in this article. However, let us focus on parsing the markdown and rendering the necessary HTML.\n\nWe are going to be using [`next-mdx-remote`](https://github.com/hashicorp/next-mdx-remote) for this tutorial. Let us install it -\n```\nnpm install next-mdx-remote\n# OR\nyarn add next-mdx-remote\n```\n\nNow, replace the code in `pages/[slug].js` with the following - \n```js\nimport { serialize } from \"next-mdx-remote/serialize\";\nimport { MDXRemote } from \"next-mdx-remote\";\n\nimport directus from \"../lib/directus\";\nimport styles from \"../styles/BlogPost.module.css\";\n\nconst BlogPage = ({ post }) => {\n  return (\n    <div className={styles.container}>\n      <h1>{post.title}</h1>\n      <MDXRemote {...post.content} />\n    </div>\n  );\n};\n\nexport const getStaticProps = async ({ params }) => {\n  const res = await directus.items(\"blog\").readByQuery({\n    filter: { slug: params.slug },\n    fields: [\"title\", \"content\"],\n  });\n\n  return {\n    props: {\n      post: {\n        title: res.data[0].title,\n        content: await serialize(res.data[0].content),\n      },\n    },\n  };\n};\n\nexport const getStaticPaths = async () => {\n  const res = await directus.items(\"blog\").readByQuery({\n    limit: -1,\n    fields: [\"slug\"],\n  });\n\n  return {\n    paths: res.data.map((post) => ({\n      params: {\n        slug: post.slug,\n      },\n    })),\n    fallback: false,\n  };\n};\n\nexport default BlogPage;\n```\n\nNow, if we navigate to a blog post, we can see the rendered markdown - \n\n![image.png](https://cdn.hashnode.com/res/hashnode/image/upload/v1651233312751/MhH0ZHt25.png align=\"left\")\n\n## Using Next.js On-demand ISR with Directus\nIf we build the Next.js application and serve a production build and then make changes in Directus, they will not reflect in our website unless we re-build it. Here we got 3 options - \n- Trigger a new build every time content is added/updated/deleted\n- Use regular ISR with a specified time for which the cache should be retained\n- Use on-demand ISR to only re-build that specific page only when it is needed\n\nWith the first option, it can be expensive and time-consuming. Re-building also invalidates the cache for all pages in many cases. This might cause issues when you are dealing with larger websites.\n\nWith the second option, there will be unnecessary API calls to our server and data might be stale.\n\nThis leaves us with the third option. Although setting it up is slightly more complicated than the other 2 methods, it does not have any of the downsides the other 2 methods have. And, I am going to show you how exactly to set it up so it shouldn't be very hard :)\n\n**Note:** Currently the website is hosted locally but Directus needs a publicly accessible URL as a webhook. You can either host it somewhere and then test it out or start a local tunnel using something like [Ngrok](https://ngrok.com/)\n\nCreate a new file under `pages/api/revalidate.js` and add the following code - \n```js\nimport directus from \"../../lib/directus\";\n\nconst handler = async (req, res) => {\n  const { collection } = req.body;\n  const headers = req.headers;\n\n  if (!headers[\"x-webhook-secret\"]) {\n    return res.status(403).send(\"Forbidden\");\n  }\n\n  const receivedSecret = headers[\"x-webhook-secret\"];\n\n  const secret = process.env.REVALIDATE_SECRET;\n\n  if (receivedSecret !== secret) {\n    return res.status(403).send(\"Forbidden\");\n  }\n\n  if (collection === \"blog\") {\n    const { keys } = req.body;\n\n    for (const key of keys) {\n      const directusRes = await directus\n        .items(collection)\n        .readOne(key, { fields: [\"slug\"] });\n\n      await res.unstable_revalidate(`/${directusRes.slug}`);\n      await res.unstable_revalidate(\"/\");\n    }\n  }\n\n  return res.status(200).send(\"Success\");\n};\n\nexport default handler;\n```\n\nThis is a simple Next.js API route.\n\nFirst, we check for the `x-webhook-secret` header and compare it to a preset webhook secret, set as an environment variable. We should always use a webhook secret to prevent spam. It can also be a security risk in some cases (but here it is not as we are not relying on data sent as an event payload for input).\n\nDirectus sends us some event payload and we are destructuring the collection field which contains the name of the collection where the change was made. We check if this is the blog collection and then go ahead with revalidating the pages. Although this does not make much sense here, if our pages had multiple sets of pages that could be revalidated, we could specifically just revalidate a set of pages instead of all sets of pages. (for example, if there was a landing and then a blog page, for changes to the landing collection, we could just revalidate the landing page but for changes to the blog page, we could revalidate only the specific blog page and the blog index).\n\nNow, the event payload does not contain the slug for the blog post but it has the id. We use the Directus SDK to get the slug corresponding to that id and then revalidate that slug page and the home page (as it has the blog index).\n\nLastly, open up the `.env.local` file and add the `REVALIDATE_SECRET` environment variable. For the value, it can be a random string. The easiest way would be to use the output of the following command - \n```\nopenssl rand -base64 32\n```\n\nTo test this out, we cannot use the development environment as `getStaticProps` runs every time a request is made on the development environment. Either build the site with `npm run build` or `yarn build`, serve it locally with `npm run start` or `yarn start`, and then use a local tunneling solution like Ngrok or else, deploy it to a hosting platform like [Vercel](https://vercel.com/).\n\nNow head over to your Directus instance and go to the settings tab. Now click on \"Webhooks\" in the side navigation and create a new one. Give it a name and for the URL field, add your Ngrok URL or your hosted instance. Make sure that the slug is `/api/revalidate`. The URL should look like `https://<my-domain>/api/revalidate`. Make sure the status is set to active and the \"Send Event Data\" checkbox is checked.\n\nNow, add a header called `x-webhook-secret` with the value of the secret you created earlier and set it as an environment variable. Under \"Triggers\", check all the actions and the blog collection. Now click the checkmark to save it. Here is what it looks like for me - \n\n![image.png](https://cdn.hashnode.com/res/hashnode/image/upload/v1651238918101/cLQGh0Por.png align=\"left\")\n\n## Conclusion\nThat has been quite a lot! Let us go over the things we did - \n- First, we create a project in Directus and created a schema for our blog posts\n- We created a Next.js application and added the Directus SDK\n- We displayed our blog posts on the home page and the post with content on its own page\n- We used `next-mdx-remote` to render markdown\n- We used Next.js on-demand ISR to revalidate the cache whenever required\n\nHope you liked this tutorial! Do share it if you have found it useful and you can follow me on [Twitter](https://twitter.com/) too :)\n\nSee you on my next blog 🤞\n\n## Important Links\n- [GitHub Repo with all the code](https://github.com/AnishDe12020/nextjs-directus-on-demand-isr)\n- [Hosted Demo](https://nextjs-directus-on-demand-isr.vercel.app/)\n- [Directus](https://directus.io/)\n- [Next.js on-demand ISR](https://nextjs.org/docs/basic-features/data-fetching/incremental-static-regeneration#on-demand-revalidation-beta)","readingTime":{"text":"13 min read","minutes":12.325,"time":739500,"words":2465},"wordCount":2465},{"_id":"6245c7a562d144fbc1c44ee7","slug":"introducing-xdox-start-challenges-log-your-progress-and-show-them-off-to-the-world","title":"Introducing XdoX - Start Challenges, Log your Progress and Show them off to the World","brief":"🤔 What is XdoX?\nXdoX is a web application that lets you start challenges and log your progress every day. You are also able to show your progress to the world via your unique profile page. These challenges can be anything from 100DaysOfCode to 30Day...","coverImage":"https://cdn.hashnode.com/res/hashnode/image/upload/v1648739175407/TYb9x3jFw.png","dateAdded":"2022-03-31T15:24:21.104Z","contentMarkdown":"## 🤔 What is XdoX?\n\nXdoX is a web application that lets you start challenges and log your progress every day. You are also able to show your progress to the world via your unique profile page. These challenges can be anything from 100DaysOfCode to 30DaysOfRust to even 60DaysOfCooking!\n\nIt is also my submission for the [Hasura x Hashnode Hackathon](https://townhall.hashnode.com/hasura-hackathon)\n\n[Live Demo](https://xdox.me/) / [GitHub Repository](https://github.com/AnishDe12020/xdox)\n\n## ❓ What is Hasura?\n\nGraphQL is a query language for APIs with a schema. It comes with multiple features like the ability to query specific fields, do pagination, do aggregation queries, and a lot more.\n\nHowever, making a GraphQL backend is more complicated than making a simple REST backend and that is where Hasura comes in. [Hasura](https://hasura.io/) provides us with an easy way to make a GraphQL backend that connects our database with our application without the need to write a single line of code!\n\nHasura also has a cloud offering with a decent free tier so that we can get started with hosting our GaphQL backend without needing to worry about costs. It is Open Source and Self-Hostable as well.\n\n## 📚 The Tech Stack\n\nWhat all technologies did I use for XdoX?\n\nFor starters, I used [Hasura](https://hasura.io/) for my application's backend.\n\nOther than that, I used the following services - \n\n- [Clerk](https://clerk.dev/) to add authentication to my application. It also integrated well with Hasura and I was able to secure my backend by using JWT Auth (more on this later on in this article)\n\n- [Heroku Postgres](https://www.heroku.com/postgres) for my database. It also integrated well with Hasura\n\n- [Vercel](https://vercel.com/) to host my frontend\n\nAnd, here are the libraries and frameworks I used for the application - \n\n- [Next.js](https://nextjs.org/) for my application's frontend\n- [TailwindCSS](https://tailwindcss.com/) for styling my frontend\n- [Radix UI](https://www.radix-ui.com/) for un-styled UI components like Modals and Popovers\n- [Headless UI](https://headlessui.dev/) for transitions\n- [Apollo React Client](https://www.apollographql.com/docs/react/) for making GraphQL requests from my frontend. It also takes care of caching.\n- [Tiptap](https://tiptap.dev/) for the rich-text editor with markdown support that is used to log progress\n\n## 🧐 How does XdoX work?\n\nIt is a simple 3-step process. One signs up for an account using Google or Email and then starts a challenge (e.g. 100DaysOfCode). Then one logs their progress every day.\n\n![image.png](https://cdn.hashnode.com/res/hashnode/image/upload/v1648735974435/jGQ7wv8a0.png)\n\nNext, one can share their unique profile page to the world to show off their progress.\n\nAlso, it is not necessary to log your progress every day. The app is built in such a way that lets you be flexible with your challenges. Gone on a vacation? No problem, XdoX won't bug out for not logging your progress.\n\n### Securing the backend\n\nBackends have direct access to the database and it is considered a best practice to secure them. I need to use the GraphQL API from my front-end and hence it has to be a public API. However, I must secure it so that only limited unauthorized requests and authorized requests can be made.\n\nAs I was using Clerk for user authentication, it didn't take me long to implement this. Clerk integrated with Hasura using JWT templates. Here is the [documentation explaining how to implement this](https://docs.clerk.dev/integrations/hasura).\n\nHere, we create a JWT template from the Clerk dashboard. Here is what mine looks like - \n\n![image.png](https://cdn.hashnode.com/res/hashnode/image/upload/v1648723772908/ke9jezE3i.png)\n\nWhen making a request to the API, we pass in a header called `Authorization` with a bearer token as the value. This is verified by Hasura using a signing key (this is set in Hasura via environment variables). \n\nThis is the code in the frontend that takes care of passing in the bearer token when making requests - \n```ts\nimport {\n  ApolloClient,\n  ApolloProvider,\n  from,\n  HttpLink,\n  InMemoryCache,\n} from \"@apollo/client\";\nimport { setContext } from \"@apollo/client/link/context\";\nimport { useSession } from \"@clerk/clerk-react\";\nimport { ReactNode } from \"react\";\n\nconst hasuraGraphqlApi = process.env.NEXT_PUBLIC_HASURA_GRAPHQL_API;\n\ninterface IApolloProviderWrapperProps {\n  children: ReactNode;\n}\n\nexport const ApolloProviderWrapper = ({\n  children,\n}: IApolloProviderWrapperProps) => {\n  const { getToken } = useSession();\n  const authMiddleware = setContext(async (_, { headers }) => {\n    const token = await getToken({ template: \"hasura\" });\n\n    return {\n      headers: {\n        ...headers,\n        authorization: `Bearer ${token}`,\n      },\n    };\n  });\n\n  const httpLink = new HttpLink({\n    uri: hasuraGraphqlApi,\n  });\n\n  const apolloClient = new ApolloClient({\n    link: from([authMiddleware, httpLink]),\n    cache: new InMemoryCache(),\n  });\n\n  return <ApolloProvider client={apolloClient}>{children}</ApolloProvider>;\n};\n```\n\nWe simply get a bearer token by using the `getToken` function made available to us by the Clerk React SDK and pass it in the `Authorization` header.\n\nNow, if the bearer token is valid, the `X-Hasura-User-Id` header is added to the request that contains the user id of the user who is making the request. The headers for the `user` role are passed in as well. Note that this is taken care of on Hasura's side. \n\nI am also making some unauthenticated requests with a `viewer` role. This has been set as the unauthorized role in my Hasura instance and is used in the public user profile pages. Here is the code that take cares of making an unauthenticated requests - \n```ts\nimport {\n  ApolloClient,\n  ApolloProvider,\n  from,\n  HttpLink,\n  InMemoryCache,\n} from \"@apollo/client\";\nimport { setContext } from \"@apollo/client/link/context\";\nimport { ReactNode } from \"react\";\n\nconst hasuraGraphqlApi = process.env.NEXT_PUBLIC_HASURA_GRAPHQL_API;\n\ninterface IApolloProviderWrapperProps {\n  children: ReactNode;\n}\n\nexport const UnauthenticatedApolloProviderWrapper = ({\n  children,\n}: IApolloProviderWrapperProps) => {\n  const authMiddleware = setContext(async (_, { headers }) => {\n    return {\n      headers: {\n        ...headers,\n        \"X-Hasura-User-Role\": \"viewer\",\n      },\n    };\n  });\n\n  const httpLink = new HttpLink({\n    uri: hasuraGraphqlApi,\n  });\n\n  const apolloClient = new ApolloClient({\n    link: from([authMiddleware, httpLink]),\n    cache: new InMemoryCache(),\n  });\n\n  return <ApolloProvider client={apolloClient}>{children}</ApolloProvider>;\n};\n```\n\n### Setting row-level permissions for the data\n\nAlthough the API is now secured, no data is accessible by default. We need to set up permissions and this will also let us limit the data one can access. For example, we will let a user only access their own user data and only access private challenges they have created.\n\nThankfully, Hasura again makes doing this extremely easy. Let us look at an example - \n\n![image.png](https://cdn.hashnode.com/res/hashnode/image/upload/v1648727072397/ZET1GtAf8.png)\n\nHere, I have setup insert permissions for the `user` role in such a way that one can insert rows only where the `user_id` column is equal to the user id of the user making the request (this was passed in as a header).\n\nI am also allowing the `user` to only update specific columns. Here, the `id` column is auto-generated with the `gen_random_uuid()` PostgreSQL function. The `created_at` and `updated_at` fields are also being taken care of by the backend.\n\nI am also adding a column preset for the `user_id` column that will be equal to the `X-Hasura-User-Id` header. Now, that is crazy powerful!\n\nSimilarly, I have set permissions for update, select and delete for the `user` role where I check that the `user_id` column matches the `X-Hasura-User-Id` header.\n\nFor the `viewer` role, I have set it up this way - \n\n![image.png](https://cdn.hashnode.com/res/hashnode/image/upload/v1648733581527/V6oGYUvmP.png)\n\nHere, the viewer is only able to select rows from the database (that is, only read data). I have additionally added a check that makes sure that the challenge is public.\n\n## 👓 What I learned from this Hackathon\nAlthough I have used GraphQL in the past, my experience was quite limited. Also, I had never built a GraphQL backend, I was just using public GraphQL APIs. I had also never used Hasura before, nor did I ever use a SQL database for any production project.\n\nThis hackathon gave me a chance to explore the backend side of GraphQL through Hasura and understand the deeper concepts. I also had a great time using a PostgreSQL database, learning more about relational data. It is crazy powerful!\n\n## ✨ Conclusion\nOver the past month, I have worked on XdoX and have been exploring and learning a LOT of new things. I'm quite excited to see how XdoX does in the real world!\n\nBye, and have a nice day 😁🤞\n\n## 🔗 Important Links\n- [XdoX](https://www.xdox.me/)\n- [XdoX GitHub Repository](https://github.com/AnishDe12020/xdox)\n- [My profile on XdoX](https://www.xdox.me/@anishde12020)\n","readingTime":{"text":"7 min read","minutes":6.59,"time":395400,"words":1318},"wordCount":1319},{"_id":"623adcbde99839749d2473f4","slug":"5-chrome-keyboard-shortcuts-to-boost-your-productivity","title":"5 Chrome Keyboard Shortcuts to boost your productivity","brief":"Browsers have become an integral part of our life and most applications are web-based now. We use web browsers for everything, from asking a question on Stackoverflow to booking a flight ticket. We often end up having a huge number of tabs open and i...","coverImage":"https://cdn.hashnode.com/res/hashnode/image/upload/v1648010384861/eZTBzzKqf.png","dateAdded":"2022-03-23T08:39:25.360Z","contentMarkdown":"Browsers have become an integral part of our life and most applications are web-based now. We use web browsers for everything, from asking a question on Stackoverflow to booking a flight ticket. We often end up having a huge number of tabs open and it becomes quite hard to keep a track of them. It gets especially confusing when we try to switch between tabs. Let us look at 5 keyboard shortcuts that can boost our productivity -\n\nNote: Although I am going to be talking about keyboard shortcuts specific to Chrome, they should remain the same across all Chromium-based browsers (Brave, Edge, Vivaldi, etc.)\n\n## Moving between tabs\nClicking tabs can be quite a painful and slow process, especially, if you switch between them frequently. Keyboard shortcuts greatly speed things up here.\n\n<kbd>Ctrl</kbd> + <kbd>Tab</kbd> (for Windows) and <kbd>⌘</kbd> + <kbd>⌥</kbd> + <kbd>→</kbd> (for macOS) lets you move to the next tab.\n\nEdit: <kbd>Ctrl</kbd> + <kbd>Tab</kbd> works on macOS too, kudos to @[Dhruva Srinivas](@carrotfarmer) for pointing it out\n\nBonus:\nWe can also move to the previous tab with <kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>Tab</kbd> (for Windows) and <kbd>⌘</kbd> + <kbd>⌥</kbd> + <kbd>←</kbd> (for macOS)\n\n## Re-opening closed tabs\nWe tend to close tabs by mistake but there is a simple keyboard shortcut that can re-open the last closed tab - \n\n<kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>t</kbd> (for Windows) and <kbd>⌘</kbd> + <kbd>Shift</kbd> + <kbd>t</kbd> (for macOS) lets you re-open recently closed tabs in the order they were closed in.\n\nBonus: If you close a whole window, the above keyboard shortcut will re-open the whole window with all the tabs.\n\n## Searching through open tabs\nAs the number of tabs open gets larger and larger, it gets difficult to find a tab. Fortunately, from Chrome 87 onwards, we can search through all open tabs, as well as recently closed tabs.\n\n<kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>a</kbd> (for Windows) and <kbd>⌘</kbd> + <kbd>Shift</kbd> + <kbd>a</kbd> (for macOS) opens the tab search dialog.\n\n## Close the current tab\nAfter we are done with using a web page on a tab, it is a good idea to close it so that it doesn't clutter our tab bar and keeps the resource usage low.\n\n<kbd>Ctrl</kbd> + <kbd>w</kbd> (for Windows) and <kbd>⌘</kbd> + <kbd>w</kbd> (for macOS) closes the current tab.\n\nBonus: <kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>w</kbd> (for Windows) and <kbd>⌘</kbd> + <kbd>Shift</kbd> + <kbd>w</kbd> (for macOS) closes the current window.\n\n## Open a new tab or a window\n<kbd>Ctrl</kbd> + <kbd>t</kbd> (for Windows) and <kbd>⌘</kbd> + <kbd>t</kbd> (for macOS) opens a new tab and jumps to it.\n\nSimilarly, <kbd>Ctrl</kbd> + <kbd>n</kbd> (for Windows) and <kbd>⌘</kbd> + <kbd>n</kbd> (for macOS) opens a new window and jumps to it.\n\nAll Chrome Keyboard Shortcuts - [https://support.google.com/chrome/answer/157179?hl=en&co=GENIE.Platform%3DDesktop](https://support.google.com/chrome/answer/157179?hl=en&co=GENIE.Platform%3DDesktop)\n\n## Conclusion\nI hope you have found this small article helpful and now you can be more productive while browsing the web. See you in the next one 🤞","readingTime":{"text":"3 min read","minutes":2.42,"time":145200,"words":484},"wordCount":484}],"domain":"blog.anishde.dev"}